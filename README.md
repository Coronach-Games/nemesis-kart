# Nemesis Kart

## How it works:

1.  **Configuration (`CONFIG`):** A dictionary holds all the tunable parameters like track length, speeds, item chances, and Nemesis system thresholds. You can change these directly in the code or using the `config` command in the debug terminal.
2.  **`Racer` Class:**
    *   Stores position, speed, current item.
    *   Includes status effects like `boost_timer` and `hit_timer`.
    *   **Nemesis Data:**
        *   `relationships`: A dictionary mapping other racer names to a score (-10 to +10). Negative means rivalry.
        *   `traits`: A set to store acquired traits (like `Aggressive`, `Shell-Shocked`).
        *   `hit_by_count`, `hit_others_count`: Track who hits whom.
    *   `update_relationship()`: Modifies the relationship score.
    *   `add_trait()`: Adds a trait if conditions are met.
    *   `check_trait_conditions()`: Simple logic to grant traits based on hit counts or relationship scores.
    *   `decide_action()`: Basic AI logic. If it has a strong negative relationship (`<= nemesis_targeting_threshold`), it prioritizes targeting that rival with offensive items. Otherwise, it uses items somewhat opportunistically or randomly.
    *   `update_step()`: Calculates movement based on speed, boosts, and hits. Checks for item boxes.
    *   `get_item()`: Assigns a random item, potentially modified by catch-up mechanics.
    *   `use_item()`: Executes the item's effect (boost, adding hit events, placing obstacles). Updates nemesis hit counts.
    *   `apply_hit()`: Processes being hit by an item, applies penalties, updates `hit_by_count`, and *decreases relationship* towards the attacker.
3.  **`Game` Class:**
    *   Manages the list of `racers`.
    *   `run_step()`: The core simulation loop for one time step:
        *   Gets decisions from all racers (AI or player input).
        *   Executes item uses and updates racer positions.
        *   Processes pending hit events generated by items.
        *   Checks for collisions with obstacles (bananas).
        *   Checks for overtakes and updates relationships (the overtaken racer dislikes the overtaker).
        *   Checks for a winner. If found, applies final relationship penalties based on finishing order.
        *   Updates racer traits.
    *   `print_status()`: Displays the current race standings and racer info.
    *   `get_racer_details()`: Shows detailed stats, traits, and relationships for a specific racer.
4.  **Debug Terminal (`if __name__ == "__main__":`)**
    *   Uses threading (`input_thread_func`) to handle user commands without blocking the simulation loop.
    *   `run`: Starts automatic simulation steps with delays.
    *   `step [n]`: Manually advances the simulation.
    *   `status [name]`: Shows racer details (using `get_racer_details`).
    *   `config [key] [value]`: Allows viewing and *modifying* `CONFIG` values at runtime.
    *   `give [racer] [item]`: Manually gives an item to a racer.
    *   `use [item] [target?]`: Queues up the player's action for the *next* simulation step.
    *   `rel [r1] [r2] [val]`: Manually sets the relationship score.
    *   `debug`: Toggles detailed debug messages.
    *   `debug_log()` / `print_debug_output()`: System for printing internal events.

## To Run:

1.  Save the code as a Python file (e.g., `nemesis_kart.py`).
2.  Run it from your terminal: `python nemesis_kart.py`
3.  Use the commands listed in the initial output to interact with the simulation.

